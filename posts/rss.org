#+TITLE: brown121407

* [[file:/home/brown/src/brown.121407.xyz/posts/2020-05-16-guix-manifests.org][GNU Guix: (Interactive) manifests]]
:PROPERTIES:
:RSS_PERMALINK: 2020-05-16-guix-manifests.html
:RSS_TITLE: GNU Guix: (Interactive) manifests
:PUBDATE:  2020-05-16
:ID:       15980e8a-7fae-40aa-9aa6-17a52e53da95
:END:
What's a manifest and where can I get one?
GNU Guix has, besides all the other cool features, a (you guessed it) cool
feature that allows users to specify what packages they want to have installed
in a given profile by using Scheme code. And since Scheme is not just a weird
configuration format, but a complete programming language, you can do whatever
you want with it. 

The file you're feeding into Guix must contain a "manifest". It's just Scheme
code that will evaluate to a manifest. What's a [[https://guix.gnu.org/manual/en/html_node/Invoking-guix-package.html#profile_002dmanifest][manifest]]? A list of packages in
Guix's own special format (not just a list of strings).

How would you create a manifest?

The simplest way is by writing a Scheme file in which you plug a list of strings
into ~specifications->manifest~:

#+begin_src scheme
  (use-modules (gnu)) ;; specifications->manifest is located inside this module

  (specifications->manifest '("emacs" "gcc-toolchain"))
#+end_src

Supposing you saved this file as =manifest.scm=, you can now feed it into Guix
with =guix package -m manifest.scm= and that will configure your profile to
contain *only* the packages written in your manifest.

How to make it even cooler
What's so great about configuring you system with code is that you can *do*
stuff in your code. It's not just a static declaration.

Let's say you have multiple machines, each of which you use for a different
purpose. On one of them, the "office box", you need LibreOffice and GNU Cash. On
another one, the "writing desk", you need Emacs, Org mode and a LaTeX
distribution. And you also have a "code box" because you like programming, don't
you?

Everything other than the specific software needed to provide the flavors to
each computer (office, writing, code) you'll want to have in common. You also
want to have an easy setup, so if you buy a new laptop instead of your current
"code box", you don't have to remember all the little programs you needed to
take sexy screenshots for r/unixporn.

Guix is here to save you!

Let's write some code that will generate a manifest interactively, allowing us
to select "classes" of software. We'll begin by defining the structure that
holds our packages and categories of packages. Good thing Scheme allows creating
dynamic structures easily with its lists:

#+caption: Software groups
#+begin_src scheme
  (define groups
    `((programming . ((c . ("gcc-toolchain"
                            "clang"
                            "gdb"
                            "ccls"))
                      (guile . ("guile"))
                      (ocaml . ("opam"))
                      (python . ("python"))
                      (php . ("php"))
                      (elisp . ("emacs"))
                      (haskell . ("ghc"
                                  "ghcid"))))
      (fonts . ("fontconfig"
                "font-adobe-source-code-pro"
                "font-gnu-unifont"
                "font-fira-code"
                "font-google-noto"
                "font-dejavu"
                "font-liberation"
                "font-awesome"))
      (emacs . ("emacs"
                "emacs-f"
                "emacs-s"
                "emacs-dash"
                "emacs-telega"
                "emacs-htmlize"))
      (mail . ("offlineimap"
               "mu"))
      (vim . ("neovim"
              "python-pynvim"
              "node"))
      (latex . ("texlive"
                "biber"))
      (office . ("libreoffice"))))
#+end_src

That is an excerpt from my own setup. As you can see, we put related software
into categories such as =fonts= or =emacs= and we can also have subcategories
(nesting is unlimited!) like =haskell= or =c= in =programming=.

The problem that arises now is how to process this structure.

I managed to hack two mutually recursive functions together that:
shows you the groups you can choose from
lets you write a list of groups
traverses those groups and:
if the group contains subgroups, do the same thing all over again for those
else take each string from the group and append it to a list

There probably is a better way to do this, but here's my solution:

#+caption: Processing functions
#+begin_src scheme
  ;; TODO: come up with a meaningful name for foo1 and foo
  (define (foo1 group group-name)
    (format #t "~%Enter a list with the tools you want to set up from the `~a' group.~%" group-name)
    (format #t "Here are the available tools: ~a.~%" (map car group))
    (newline)
    (letrec ((selected (read))
             (loop (lambda (l acc)
                     (if (null? l)
                         acc
                         (loop (cdr l) (append acc (foo (assoc-ref group (car l)) (car l))))))))
      (loop (if (equal? selected 'all)
                (map car group)
                selected)
            '())))

  (define (foo group group-name)
    (if (list? (car group))
        (foo1 group group-name)
        group))
#+end_src

(You'll need to import ~(ice-9 format)~ for the ~format~ function.)

After loading this, try running =(foo1 groups "all")=. It should give you the
prompt to select groups and after you go through all that, it should return a
list of strings representing the names of all the packages you want installed.

To turn this into the correct representation for Guix, remember our good friend
=specifications->manifest=.

#+caption: That's all folks
#+begin_src scheme
  (define to-install (foo1 groups "all"))

  (specifications->manifest to-install)
#+end_src

If you put all this stuff into a file, you can feed it into =guix package -m=
just like before. Since Guix and Scheme are cool they will evaluate your whole
script and prompt you to say what groups of software you want installed, just
like you told them to.

** Edit <2020-07-11 Sat>
:PROPERTIES:
:ID:       fb30e898-5bca-42e2-a8db-c19157c88d37
:END:
I talked to a friend about this and he told me that it would be useful to make
this accept packages too (package objects, not strings) in the groups.

It turns out that this is extremely easy to implement. Just drop the package
objects where you want them in the groups and replace the last line:

#+begin_src scheme
  (specifications->manifest to-install)
#+end_src

with:

#+begin_src scheme
  (concatenate-manifests
   (list (specifications->manifest (filter string? to-install))
         (packages->manifest (filter package? to-install))))
#+end_src

For this you'll need to also include the ~(guix packages)~ and ~(guix profiles)~
modules.
* [[file:/home/brown/src/brown.121407.xyz/posts/2020-04-16-emacs-daemon-always.org][Start Emacs as a daemon]]
:PROPERTIES:
:RSS_PERMALINK: 2020-04-16-emacs-daemon-always.html
:RSS_TITLE: Start Emacs as a daemon
:PUBDATE:  2020-04-16
:ID:       deca2605-4f29-41e2-9bfd-b7f6c8a7505a
:END:
One of the great things about Emacs is that it can be
daemonized. People always complain how their editors and IDEs turn so
heavy that they can go take a nap while waiting for those to start
up. Emacs, although being known as "the bloatfest" of editors, can
manage the situation quite nicely by starting as a daemon:

#+begin_src bash
  emacs --daemon
#+end_src

It's that simple. When you start Emacs as a daemon, it loads all your
settings and plugins in the background and keeps them in memory. You
will notice that if you start Emacs the normal way after you turned on
a daemon, you will feel no difference. That's because you don't use
~emacs~ to connect to the daemon, you use ~emacsclient~. Please issue
a ~emacsclient --help~ in your terminal to see the available options.

Most of the time you will want to create a new window (or frame,
whatever Emacs calls its stuff). By default, if you only provide a
filename to ~emascclient~, it will try to open it in an already
existing frame. To open it in a new one, use ~emacsclient -c~ or
~emacsclient --create-frame~.

Now, using emacsclient, you will notice that your files open instantly
and all your settings are loaded correctly. If you use Emacs
frequently I recommend starting the daemon when you boot into the
system. Myself, I use a wrapper script that checks if there is any
running daemon --- if there is, connect to it, otherwise start one and
then connect.

#+begin_src bash
  #!/bin/sh

  ps aux | grep "[e]macs.*daemon" || emacs --daemon && emacsclient -c "$@" &
#+end_src

Another benefit of editing with a daemon is that your buffers stay
open even if you close your window. I actually closed this by mistake
while writing the previous paragraph but after a quick, whispered
"fuck", I remembered the whole thing is still in memory. Cool.
* [[file:/home/brown/src/brown.121407.xyz/posts/2020-03-16-preferred-gnu-linux-distros.org][My preferred GNU/Linux distributions]]
:PROPERTIES:
:RSS_PERMALINK: 2020-03-16-preferred-gnu-linux-distros.html
:RSS_TITLE: My preferred GNU/Linux distributions
:PUBDATE:  2020-03-16
:ID:       bf32409f-de9a-40d2-b667-25b1e1979c98
:END:
For hackers and free software enthusiasts
** GNU Guix System
:PROPERTIES:
:ID:       dba0f7f5-a38e-4770-81df-c5a46be54d59
:END:
The [[https://guix.gnu.org/][Guix System]] is a distribution of the GNU operating system based on
the Guix package manager.

There are better chances you've heard of Nix. From the GNU Guix manual:

#+begin_quote
Guix is based on the [[https://nixos.org/nix/][Nix package manager]], which was designed and
implemented by Eelco Dolstra, with contributions from other people
(see the nix/AUTHORS file in Guix.) Nix pioneered functional package
management, and promoted unprecedented features, such as transactional
package upgrades and rollbacks, per-user profiles, and referentially
transparent build processes. Without this work, Guix would not exist.
#+end_quote

The terminology for Guix may be a bit confusing. When someone says
they are using Guix, the may be referring to either using the Guix
/package manager/ on a foreign distro, or actually using the GNU
distribution, which is usually differentiated by calling it the /Guix
System/. So:

plain "Guix" = maybe the package manager, maybe the distro
"Guix System" = the GNU distribution

Note how I don't specifically say GNU/Linux distribution. That is
because, despite basically everyone using Guix as with the Linux
kernel, there is the possibility to use another kernel, such as Hurd.

*** What do I like about Guix?
:PROPERTIES:
:ID:       426c7910-291a-45cd-89fa-91788455888f
:END:
Technicalities aside, Guix is a GNU distribution that features only
free software in its official repository. This is a thing I deeply
respect, and it turns out I can do everything I need on a computer
only with free software. I am running Guix for about half a year now
and I love it.

Guix uses/is a *functional package manager*. I can't explain why it's
cool good enough so I recommend you read what [[https://nixos.org/nix/about.html][Nix has to say]] on that
and a bit of [[https://guix.gnu.org/manual/en/html_node/Managing-Software-the-Guix-Way.html#Managing-Software-the-Guix-Way][the Guix manual]].

A good thing that comes from this is being able to have multiple
system "generations" saved. That means that if, right now, I do a
system upgrade and things get messed up, I can revert easily to the
previous state of the system by booting up the previous generation
(you can select those in the bootloader menu).

Another nice thing about Guix is how it manages packaging. All
packages are describes using Scheme code and they are stored in a git
repo. Take a look at the =hello= program's recipe:

#+begin_src scheme
  (define-public hello
    (package
      (name "hello")
      (version "2.10")
      (source (origin
                (method url-fetch)
                (uri (string-append "mirror://gnu/hello/hello-" version
                                    ".tar.gz"))
                (sha256
                 (base32
                  "0ssi1wpaf7plaswqqjwigppsg5fyh99vdlb9kzl7c9lng89ndq1i"))))
      (build-system gnu-build-system)
      (synopsis "Hello, GNU world: An example GNU package")
      (description
       "GNU Hello prints the message \"Hello, world!\" and then exits.  It
  serves as an example of standard GNU coding practices.  As such, it supports
  command-line arguments, multiple languages, and so on.")
      (home-page "https://www.gnu.org/software/hello/")
      (license gpl3+)))
#+end_src

Because all packages are pretty descriptive code in a public git repo,
Guix accepts patches from anybody for updating, fixing or adding new
definitions. Because the whole process is extremely simple it allowed
me to get 21 commits into the master branch at the time of writing
with no prior contributions done to a GNU/Linux distribution.

Thanks to the way Guix is built, one more great thing that it features
is represented by its environments. An environment is a
temporary... uh... environment? with a selected set of
packages. You're basically dropping into a shell that has a different
set of packages than your normal one, set specifically tailored for
some purpose, such as building a program. If I play with Guix's own
source code, I don't have to install all of its dependencies
permanently on my system. I can have a temporary shell with them for
as long as I need to work on that code with ~guix environment guix~.

I mentioned earlier that packages are Scheme code. Well, in Guix,
pretty much everything is Scheme code. Even the base system
configuration is Scheme code. Take a look at this: [[https://guix.gnu.org/manual/en/html_node/Using-the-Configuration-System.html#Using-the-Configuration-System][Using the
Configuration System]].

[[https://guix.gnu.org/manual/en/html_node/Channels.html][Channels]] are great too. Basically the Arch AUR but on steroids and
everyone can make one. Cooler than PPAs.

*** What do I dislike about Guix?
:PROPERTIES:
:ID:       6db39505-2f3e-46f2-af4e-21dd78cf6b3e
:END:
Not all the packages one would need, or not the latest versions. There
are not as many people working on it as I'd like. This is not
something that happens because Guix is bad in some way, it's just that
it's so new and different not many people use it, fewer even
contribute.

The package manager is noticeably slower than others. If you use an
Arch machine after playing with Guix you'd think you were in slow
motion before using =pacman=. Why does "building database for manual
pages" take so damn long?

Not necessarily a dislike for me but worth mentioning: be prepared to do some
compilation! Since Guix basically has recipes to build everything from source,
if something isn't already built on their [[https://guix.gnu.org/manual/en/html_node/Substitutes.html#Substitutes][substitutes]] server, your machine is
going to do it. Most of the time you'll be fine, especially if you keep pull all
the new definitions today and upgrade tomorrow, for example.

**** EDIT <2020-07-09 Thu>
:PROPERTIES:
:ID:       4003dc96-867b-458b-bc27-ec2d292c58cb
:END:
Guix got faster now because of Guile 3.0. Not pacman fast but faster.

For moderate geeks
** Arch Linux
:PROPERTIES:
:ID:       a5b0fb70-92b0-4600-b338-b7b58aab02ee
:END:
If you prefer something more established than Guix, something where
you can still tinker a lot but is more mainstream, I can recommend
Arch (I never tried Gentoo).

*** What do I like about Arch?
:PROPERTIES:
:ID:       db7ae4e3-3c33-43a3-84b0-defa16c100f8
:END:
When shit breaks when updating, the solution is always on Arch's
website.

Makes it easy to install proprietary software.

The AUR.

Fast package manager.

Bigger community and more packages than other distributions, such as
Guix.

Great documentation. I really love the Arch wiki, and everyone that
ever touched a GNU/Linux system probably does too.

You can run games on it! (Proprietary software bad tho.) Arch (and Arch
derivatives) are great for playing video games because they have the
latest drivers and software available so it's likely you will have the
newest advancements in game tech always available.

*** What do I dislike about Arch?
:PROPERTIES:
:ID:       4a76b63b-28f2-4f56-8caf-cb66156d9a10
:END:
Shit breaks sometimes when updating.

Makes it easy to install proprietary software.

The AUR could be better (see Guix channels).

The packaging procedure is a bit underwhelming after dealing with
Guix. On Arch, there's a [[https://wiki.archlinux.org/index.php/Trusted_Users][select bunch of people]] that actually manage
the packages in the official repos. I prefer Guix's approach ---
everyone can send in patches for any package, and if they are good,
they get in. No "official maintainer" for stuff. I got some new
packages into the official Guix repo without having any special label
on me.

For normal people
** Manjaro
:PROPERTIES:
:ID:       554fec6c-60c4-45eb-9b67-aec7fea80684
:END:
Manjaro is basically Arch for people than want the benefits of Arch
but don't want to be bothered with setting everything up themselves
(and there's nothing wrong with that).

*** What do I like about Manjaro?
:PROPERTIES:
:ID:       801a9f05-bb1b-475b-a891-6ed0e889fdf2
:END:
Whatever I like about Arch.

Easy installation process and it's also nice that they have some
driver management. I always got confused on plain Arch about what
graphics drivers I have installed and running.

*ARM support*. I see that they don't have a RPI3 image anymore ([[https://manjaro.org/download/#ARM][they
have images for a lot of other hardware]]), but I remember having it
installed on my board about half a year ago and it was the nicest
experience I ever had with my Pi.

*** What do I dislike about Manjaro?
:PROPERTIES:
:ID:       6d060cce-5f11-413a-b44d-dec6cd449980
:END:
Whatever I dislike about Arch.

Sometimes feels unnecessarily bloated, but I guess that's the cost of
having a /fully working/, preconfigured machine. =¯\_(ツ)_/¯=

Packages seem to come way faster on Arch -- I don't think there's a day when
=pacman -Syu= doesn't do anything. But on Manjaro, the updates don't seem to be
so frequent.

My current setup
For the moment, I dual boot GNU Guix System and Manjaro. I use Manjaro
to occasionally play Age of Empires 2 and use whatever proprietary
shit my school forces me to use from time to time. Guix System is my
primary operating system and *I love it*.

** EDIT <2020-07-09 Thu>
:PROPERTIES:
:ID:       a47ade93-47cf-44ef-a5ea-473c6304a73c
:END:
I ditched Manjaro on my desktop and I only use Guix now.
* [[file:/home/brown/src/brown.121407.xyz/posts/2020-02-22-stumpwm-fonts.org][StumpWM and fonts]]
:PROPERTIES:
:RSS_PERMALINK: 2020-02-22-stumpwm-fonts.html
:RSS_TITLE: StumpWM and fonts
:PUBDATE:  2020-02-22
:ID:       6f973761-505e-4b85-9b0e-dfd0c826b636
:END:
Getting StumpWM to play nice with fonts was a headache on my HiDPI
laptop so I thought to write a post about my adventure to help others
who may want to modify the appearance of this great window manager.

StumpWM Contrib
First of all, you're going to need the [[https://github.com/stumpwm/stumpwm-contrib/][contrib repo]] --- a collection
of StumpWM modules. Clone that somewhere on your computer, preferably
in the same directory with your StumpWM config.

I have my config in =~/.config/stumpwm=, so I cloned that repo into
=~/.config/stumpwm/stumpwm-contrib=.

#+begin_src lisp
  (defvar *stumpwm-config-dir* "~/.config/stumpwm")
  (set-module-dir "~/.config/stumpwm/stumpwm-contrib")
#+end_src

Then you'll need to load a specific module for fonts:

#+begin_src lisp
  (load-module "ttf-fonts")
#+end_src

Changing fonts
To make StumpWM use a specific font, you'd write something like this:

#+begin_src lisp
  (set-font (make-instance 'xft:font
                           :family "Source Code Pro"
                           :subfamily "Regular"
                           :size 10))
#+end_src

But none of this will work, because you're missing a
dependency. ~ttf-fonts~ requires ~clx-truetype~. This package seems to
no longer be available on quicklisp, but I managed to find the sources
and put up [[https://git.sr.ht/~brown121407/clx-truetype][a repository]] along with [[https://git.sr.ht/~brown121407/guix.121407.xyz/tree/master/channel/non-gnu/packages/lisp.scm#L33][a Guix package]].

I don't know how you would go about installing clx-truetype if you're
not on Guix and your distribution doesn't have it packaged already (I
think Arch has it in their repos).

If you have the luck to be on Guix, to get it first add my channel to
your =~/.config/guix/channels.scm=:

#+begin_src scheme
  (append
   (list ;; your other channels
         (channel
          (name 'brown121407)
          (url "https://git.sr.ht/~brown121407/guix.121407.xyz")))
   %default-channels)
#+end_src

Do a ~guix pull~ after that and then ~guix install
  sbcl-clx-truetype~. You should be ready now.

One more thing you need to do is put this into your StumpWM config,
before ~set-font~, and follow the advice given in the comment (this
applies for the first setup too, because you want fonts to be
indexed):

#+begin_src lisp
  ;; Uncomment this whenever installing new fonts to refresh cache
  ;;(xft:cache-fonts)
#+end_src


